'use strict';

// external modules
var _           = require('lodash');
var immutable   = require('immutable');
var assert      = require('assert-plus');
var Toposort    = require('toposort-class');

// internal files
var helpers     = require('./helpers');


//------------------------------------------------------------------------------
// class definition
//------------------------------------------------------------------------------


/**
 * Class definition
 * @public
 * @class
 * @param {Object} config            user configuration object.
 * @param {String} config.name       a name for your conductor
 * @param {Array}  [config.deps]     an array of dependencies to be mixed in
 * @param {Object} [config.props]    props to create for this conductor.
 * @param {Object} [config.handlers] an object or array of handlers
 */
function Conductor(config) {

    // assert required options
    assert.object(config, 'config');
    assert.string(config.name, 'config.name');

    // assert optional
    assert.optionalArrayOfObject(config.deps, 'config.deps');
    assert.optionalFunc(config.props, 'config.props');

    // since models and handlers can be either objects or arrays, how do we
    // assert them? optionalArrayOrObject?


    //----------------------------------------------------------
    // initialize public properties
    //----------------------------------------------------------

    /**
     * name of the conductor
     * @public
     * @type {String}
     */
    this.name = config.name;

    //----------------------------------------------------------
    // initialize private properties
    //----------------------------------------------------------

    /**
     * map of conductor names to conductor objects for all dependent conductors.
     * @private
     * @type {Object}
     */
    this._registry = {};

    /**
     * an array of conductor names, in order, for the flattened dependency
     * conductors.
     * @private
     * @type {Array}
     */
    this._sortedDeps = [];

    /**
     * the finalized version of props used by the conductor.
     * serves as an accumulator as we traverse the dependency tree, and is then
     * frozen and becomes immutable as the constructor finishes up.
     * @private
     * @type {Object}
     */
    this._props = {};

    /**
     * An object where keys are numbers and vals are an array of functions.
     * each array is a mini handler array, or handler block.
     * created by mergeHandlers().
     * @private
     * @type {Object}
     */
    this._handlers = {};

    /**
     * the finalized version of models used by the conductor.
     * includes all models passed in, plus any potentially inherited models.
     * created by mergeModels().
     * @private
     * @type {Object}
     */
    this._models = {};

    /**
     * an array of sorted handler keys.
     * the final result of sorting all flattened.
     * @private
     * @type {Array}
     */
    this._sortedHandlerKeys = [];

    /**
     * the configuration object passsed in for this conductor.
     * store it here so that when we merge dependencies later we can use
     * these instead of the flattened values.
     * @private
     * @type {Object}
     */
    this._config = {
        /**
         * an array of dependency conductors
         * @private
         * @type {Array}
         */
        deps: config.deps || [],

        /**
         * an object map, all values are arrays of functions (handlers).
         * keys can be any string, but most likely numbers.
         * @private
         * @type {Array | Object}
         */
        handlers: config.handlers || {},

        /**
         * object of props. generated by a props function that's passed in.
         * default to empty object first, we'll start appending to this
         * value as we merged down the dependency tree.
         * @private
         * @type    {Function}
         * @param   {Object} inheritedProps the initial props given to the conductor
         * @returns {Object}
         */
        propsFn: config.props || function setDefaultProps(inheritedProps) {
            return inheritedProps || {};
        },

        /**
         * key/val pair where val is an array of functions returning instances
         * of Models. keys allow you to specify multiple buckets of models. e.g.,
         * {
         *      bucketA: [ model1, model2 ],
         *      bucketB: [ model3, model4 ]
         * }
         * @private
         * @type {Object}
         */
        models: config.models || {}
    };


    // first, sort the dependencies.
    // this call is recursive, will walk through all deps and sort
    // and flatten them.
    this._sortedDeps = this._sortDeps(this);

    // now that dependencies are sorted, merge all the props, handlers, models.
    this._mergeDeps();

    // lastly, sort the finalized handler keys, after we've created all the oban
    // props.  do this now so we don't have to do it at run time to determine
    // the correct run time order.
    this._sortedHandlerKeys = helpers.sortNumericalKeys(this._handlers);

    // now freeze the props after merging them all down!
    this._props = immutable.Map(this._props);  // eslint-disable-line new-cap
}


//------------------------------------------------------------------------------
// private prototype methods
//------------------------------------------------------------------------------


/**
 * crawl the dependency tree, and tsort the deps
 * @private
 * @function  _sortDeps
 * @param     {Object} conductor an instance of this conductor class
 * @param     {Object} [tsort]   an instance of tsort utility, only exists when recursive.
 * @returns   {Array}            a sorted array of Conductor names
 */
Conductor.prototype._sortDeps = function(conductor, tsort) {

    var localTsort = tsort;
    var len = conductor._config.deps && conductor._config.deps.length;
    var i;


    // must use for loop here to guarantee order!
    // go down the rabbit hole if we have deps.
    for (i = 0; i < len; i++) {

        var dep = conductor._config.deps[i];

        // if tsort doesn't exist yet (because it's not recursive),
        // create a new tsort bucket.
        if (!localTsort) {
            localTsort = new Toposort();
        }

        // go down the deps tree and keep adding
        this._sortDeps(dep, localTsort);

        // add to tsort after we've added all children
        localTsort.add(conductor.name, dep.name);
    }

    // add the configuration to internal registry.
    this._registry[conductor.name] = conductor;

    // this next section is executed on every recursive call.
    // the tsort object is the accumulator for building deps tree.
    // if we had deps, we'll return the sorted tree, otherwise
    // we will return ourselves.

    // if there were deps, return the sorted deps
    if (localTsort) {
        return localTsort.sort();
    } else {
        // if no tsort bucket exists, we had no deps.
        // just return the current conductor
        return [conductor.name];
    }
};


/**
 * once we have the flattened dependency tree, loop through them one by one
 * and merge props, models, and handlers.
 * @private
 * @function _mergeDeps
 * @returns  {undefined}
 */
Conductor.prototype._mergeDeps = function() {

    var i = this._sortedDeps.length;
    var depName;
    var dep;

    // loop through deps in reverse order, start merging the configs down.
    // reverse order is necessary to build the dependency tree in the right
    // order.
    while (i--) {
        depName = this._sortedDeps[i];
        dep = this._registry[depName];

        // merge special constructs.
        // pass in existing values to mutate/accumulate as we go up the tree.
        // merge props
        this._props = dep._config.propsFn(this._props);
        // merge models
        this._models = helpers.mergeObjArrays(this._models, dep._config.models);
        // merge handlers
        this._handlers = helpers.mergeObjArrays(this._handlers,
                                               dep._config.handlers);
    }
};


//------------------------------------------------------------------------------
// public prototype methods
//------------------------------------------------------------------------------


/**
 * retrieves a handler block for a given key.
 * @public
 * @function getHandlers
 * @param    {String} key the key of the handler block
 * @returns  {Array}      an array of function handlers
 */
Conductor.prototype.getHandlers = function(key) {

    assert.notEqual(key, undefined, 'key'); // eslint-disable-line no-undefined
    assert.notEqual(key, null, 'key');

    if (!this._handlers[key]) {
        throw new Error('Attempted to retrieve an invalid handler block!');
    }

    return this._handlers[key];
};


/**
 * retrieves the sorted handler keys for the conductor.
 * @public
 * @function getHandlerKeys
 * @returns  {Array}      an array of strings
 */
Conductor.prototype.getHandlerKeys = function() {
    return this._sortedHandlerKeys;
};


/**
 * retrieves an immutable property.
 * if no name passed in, return all props.
 * @public
 * @function getProps
 * @param   {String} [name] optional name of the prop to retrieve.
 * @returns {Object}        the copy of the prop
 */
Conductor.prototype.getProps = function(name) {

    assert.optionalString(name, 'name');

    var props = this._props.toObject();

    // if no name passed in, return all props
    if (!name) {
        return props;
    }

    // otherwise, return the name specified
    return props[name];
};


/**
 * iterates through a specific model bucket, invoking each function in the array
 * to create a new instance of a model. does not change any state.
 * @public
 * @static
 * @function createModels
 * @param    {Object} req        the request object
 * @param    {Object} res        the response object
 * @param    {String} bucketName the name of the model bucket to create.
 * @returns  {Array}             an array of models
 */
Conductor.prototype.createModels = function(req, res, bucketName) {

    assert.object(req, 'req');
    assert.object(res, 'res');

    // if modelBucket is not passed in, models might be using a single
    // flattened array, instead of a complex bucketed scenario.
    // in this scenario, bucketName is just index 0
    var normalizedBucketName = bucketName || '0';

    // retrieve the oban container for this bucket of models
    var bucket = this._models[normalizedBucketName];

    return _.reduce(bucket, function(acc, modelFn) {
        var model = modelFn(req, res);
        acc.push(model);
        return acc;
    }, []);
};


/**
 * returns a flattened list of handler stacks.
 * for debug use only.
 * @public
 * @function getDebugHandlerStack
 * @returns  {Array} an array of function names and the index of their blocks
 */
Conductor.prototype.getDebugHandlerStack = function() {

    return _.reduce(this._handlers, function(acc, block, key) {
        // loop through each handler block, get each handler name for
        // debug console logging.
        _.forEach(block, function(handler) {
            acc.push(key + '-' + (handler.name || '?'));
        });
        return acc;
    }, []);
};



module.exports = Conductor;

'use strict';

// external modules
var _ = require('lodash');
var immutable = require('immutable');
var assert = require('assert-plus');
var Toposort = require('toposort-class');

// internal files
var helpers = require('./helpers');

//------------------------------------------------------------------------------
// class definition
//------------------------------------------------------------------------------

/**
 * Class definition
 * @public
 * @class
 * @param {Object} config            user configuration object.
 * @param {String} config.name       a name for your conductor
 * @param {Array}  [config.deps]     an array of dependencies to be mixed in
 * @param {Object} [config.props]    props to create for this conductor.
 * @param {Object} [config.handlers] an object or array of handlers
 */
function Conductor(config) {
    var self = this;

    // assert required options
    assert.object(config, 'config');
    assert.string(config.name, 'config.name');

    // assert optional
    assert.optionalArrayOfObject(config.deps, 'config.deps');

    // since models and handlers can be either objects or arrays, how do we
    // assert them? optionalArrayOrObject?

    //----------------------------------------------------------
    // initialize public properties
    //----------------------------------------------------------

    /**
     * name of the conductor
     * @public
     * @type {String}
     */
    this.name = config.name;

    //----------------------------------------------------------
    // initialize private properties
    //----------------------------------------------------------

    /**
     * map of conductor names to conductor objects for all dependent conductors.
     * @private
     * @type {Object}
     */
    this._registry = {};

    /**
     * an array of conductor names, in order, for the flattened dependency
     * conductors.
     * @private
     * @type {Array}
     */
    this._sortedDeps = [];

    /**
     * the finalized version of props used by the conductor.
     * serves as an accumulator as we traverse the dependency tree, and is then
     * frozen and becomes immutable as the constructor finishes up.
     * @private
     * @type {Object}
     */
    this._props = {};

    /**
     * An object where keys are numbers and vals are an array of functions.
     * each array is a mini handler array, or handler block.
     * created by mergeHandlers().
     * @private
     * @type {Object}
     */
    this._handlers = {};

    /**
     * the finalized version of models used by the conductor.
     * includes all models passed in, plus any potentially inherited models.
     * created by mergeModels().
     * @private
     * @type {Object}
     */
    this._models = {};

    /**
     * an array of sorted handler keys.
     * the final result of sorting all flattened.
     * @private
     * @type {Array}
     */
    this._sortedHandlerKeys = [];

    /**
     * the configuration object passsed in for this conductor.
     * store it here so that when we merge dependencies later we can use
     * these instead of the flattened values.
     * @private
     * @type {Object}
     */
    this._config = {
        /**
         * an array of dependency conductors
         * @private
         * @type {Array}
         */
        deps: config.deps || [],

        /**
         * an object map, all values are arrays of functions (handlers).
         * keys can be any string, but most likely numbers.
         * @private
         * @type {Array | Object}
         */
        handlers: config.handlers || {},

        /**
         * object of props. generated by a props function that's passed in.
         * default to empty object first, we'll start appending to this
         * value as we merged down the dependency tree.
         * @private
         * @type    {Function}
         * @param   {Object} inheritedProps the initial props given to the conductor
         * @returns {Object}
         */
        propsFn: null,
        /**
         * key/val pair where val is an array of functions returning instances
         * of Models. keys allow you to specify multiple buckets of models. e.g.,
         * {
         *      bucketA: [ model1, model2 ],
         *      bucketB: [ model3, model4 ]
         * }
         * @private
         * @type {Object}
         */
        models: config.models || {}
    };

    // This will be the normal case, devs should pass a function to handle
    // props
    if (_.isFunction(config.props)) {
        this._config.propsFn = config.props;
    } else if (_.isPlainObject(config.props)) {
        // If props isn't a function and is instead an object, wrap it
        this._config.propsFn = function setWrapperProps() {
            return config.props;
        };
    } else {
        // Wrapper for generating default props for a conductor
        this._config.propsFn = function setDefaultProps(inheritedProps) {
            return inheritedProps || {};
        };
    }

    // Determine if the propsFn passed is now a proper function after
    // being wrapped or not. If it wasn't a plain object it won't now be
    // wrapped by a function so this assert will fail
    assert.func(this._config.propsFn, 'config.props');

    // first, sort the dependencies.
    // this call is recursive, will walk through all deps and sort
    // and flatten them.
    this._sortedDeps = this._sortDeps(this);

    // now that dependencies are sorted, merge all the props, handlers, models.
    this._mergeDeps();

    // this._handlers is an array of handler arrays, so loop in to the
    // lowest level to check for each one being a function
    _.map(this._handlers, function(handlers) {
        _.map(handlers, function(handler) {
            if (!_.isFunction(handler)) {
                assert.func(
                    handler,
                    'handler is not a function in conductor: ' + self.name
                );
            }
        });
    });

    // lastly, sort the finalized handler keys, after we've created all the oban
    // props.  do this now so we don't have to do it at run time to determine
    // the correct run time order.
    this._sortedHandlerKeys = helpers.sortNumericalKeys(this._handlers);

    // now freeze the props after merging them all down!
    this._props = immutable.Map(this._props); // eslint-disable-line new-cap
}

//------------------------------------------------------------------------------
// private prototype methods
//------------------------------------------------------------------------------

/**
 * crawl the dependency tree, and tsort the deps
 * @private
 * @function  _sortDeps
 * @param     {Object} conductor an instance of this conductor class
 * @param     {Object} [tsort]   an instance of tsort utility, only exists when recursive.
 * @returns   {Array}            a sorted array of Conductor names
 */
Conductor.prototype._sortDeps = function(conductor, tsort) {
    var localTsort = tsort;
    var len = conductor._config.deps && conductor._config.deps.length;
    var i;

    // must use for loop here to guarantee order!
    // go down the rabbit hole if we have deps.
    for (i = 0; i < len; i++) {
        var dep = conductor._config.deps[i];

        // if tsort doesn't exist yet (because it's not recursive),
        // create a new tsort bucket.
        if (!localTsort) {
            localTsort = new Toposort();
        }

        // go down the deps tree and keep adding
        this._sortDeps(dep, localTsort);

        // add to tsort after we've added all children
        localTsort.add(conductor.name, dep.name);
    }

    // add the configuration to internal registry.
    this._registry[conductor.name] = conductor;

    // this next section is executed on every recursive call.
    // the tsort object is the accumulator for building deps tree.
    // if we had deps, we'll return the sorted tree, otherwise
    // we will return ourselves.

    // if there were deps, return the sorted deps
    if (localTsort) {
        return localTsort.sort();
    } else {
        // if no tsort bucket exists, we had no deps.
        // just return the current conductor
        return [conductor.name];
    }
};

/**
 * once we have the flattened dependency tree, loop through them one by one
 * and merge props, models, and handlers.
 * @private
 * @function _mergeDeps
 * @returns  {undefined}
 */
Conductor.prototype._mergeDeps = function() {
    var i = this._sortedDeps.length;
    var depName;
    var dep;

    // loop through deps in reverse order, start merging the configs down.
    // reverse order is necessary to build the dependency tree in the right
    // order.
    while (i--) {
        depName = this._sortedDeps[i];
        dep = this._registry[depName];

        // merge special constructs.
        // pass in existing values to mutate/accumulate as we go up the tree.
        // merge props
        this._props = dep._config.propsFn(this._props);
        // merge models
        this._models = helpers.mergeObjArrays(this._models, dep._config.models);
        // merge handlers
        this._handlers = helpers.mergeObjArrays(
            this._handlers,
            dep._config.handlers
        );
    }
};

//------------------------------------------------------------------------------
// public prototype methods
//------------------------------------------------------------------------------

/**
 * retrieves a handler block for a given key.
 * @public
 * @function getHandlers
 * @param    {String} key the key of the handler block
 * @returns  {Array}      an array of function handlers
 */
Conductor.prototype.getHandlers = function(key) {
    assert.notEqual(key, undefined, 'key'); // eslint-disable-line no-undefined
    assert.notEqual(key, null, 'key');

    if (!this._handlers[key]) {
        throw new Error('Attempted to retrieve an invalid handler block!');
    }

    return this._handlers[key];
};

/**
 * retrieves the sorted handler keys for the conductor.
 * @public
 * @function getHandlerKeys
 * @returns  {Array}      an array of strings
 */
Conductor.prototype.getHandlerKeys = function() {
    return this._sortedHandlerKeys;
};

/**
 * retrieves an immutable property.
 * if no name passed in, return all props.
 * @public
 * @function getProps
 * @param   {String} [name] optional name of the prop to retrieve.
 * @returns {Object}        the copy of the prop
 */
Conductor.prototype.getProps = function(name) {
    assert.optionalString(name, 'name');

    var props = this._props.toObject();

    // if no name passed in, return all props
    if (!name) {
        return props;
    }

    // otherwise, return the name specified
    return props[name];
};

/**
 * iterates through a specific model bucket, invoking each function in the array
 * to create a new instance of a model. does not change any state.
 * @public
 * @static
 * @function createModels
 * @param    {Object} req        the request object
 * @param    {Object} res        the response object
 * @param    {String} bucketName the name of the model bucket to create.
 * @returns  {Array}             an array of models
 */
Conductor.prototype.createModels = function(req, res, bucketName) {
    assert.object(req, 'req');
    assert.object(res, 'res');

    // if modelBucket is not passed in, models might be using a single
    // flattened array, instead of a complex bucketed scenario.
    // in this scenario, bucketName is just index 0
    var normalizedBucketName = bucketName || '0';

    // retrieve the oban container for this bucket of models
    var bucket = this._models[normalizedBucketName];

    return _.reduce(
        bucket,
        function(acc, modelFn) {
            var model = modelFn(req, res);
            acc.push(model);
            return acc;
        },
        []
    );
};

/**
 * returns a flattened list of handler stacks.
 * for debug use only.
 * @public
 * @function getDebugHandlerStack
 * @returns  {Array} an array of function names and the index of their blocks
 */
Conductor.prototype.getDebugHandlerStack = function() {
    return _.reduce(
        this._handlers,
        function(acc, block, key) {
            // loop through each handler block, get each handler name for
            // debug console logging.
            _.forEach(block, function(handler) {
                acc.push(key + '-' + (handler.name || '?'));
            });
            return acc;
        },
        []
    );
};

module.exports = Conductor;
